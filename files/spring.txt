Основні засади
	* POJO
	* Dependency injection (Wiring, контекст..)
	* AOP
	* Шаблони

__________________________________________________________________________________________________________
Wiring
1. Один из вариантов - это в конструктор передать интерфейс
2. Контекст Spring загружает определенмия компонентов и связывает их вместе. 
3. За создание и связывание компонентов отвечает Контест приложения
4. В Spring нексолько реализаций Контекста:
	* XML ?
	
__________________________________________________________________________________________________________
Аспектно-ориентированное программирование
AOP-выделяем службы, которые можно запускать перед каждым и после каждого выполнения.
Цель - отделить POJO от рутинных операций
В конфигурационном файле Spring (в простанстве имен OAP конфигурации) объявляем аспект:
	* сам класс, который отвечает за аспект, может быть простым POJO
	* его необходимо сделать компонентом, например, бином
	* в разделе конфигурации <aop: config> объявляем сам аспект
	* pointcut - точка внедрения - к выполнению чего буде прилагаться аспект
	* before pointcut - что запускается перед точкой
	* after pointcut - что запускается после
	* описания вызовов ведуться на синтексисе языка выражений AspectJ точек внедрения 
	
__________________________________________________________________________________________________________
Контейнер
1. Что делает
	1. Создает объекты
	2. Связывает
	3. Конфигурирует
	4. Управляет WF (from new() to finalize())
2. Контейнер находится в ядре Spring
3. Типы контейнеров:
	bean factories
	application contexts:
		* ClassPathXmlapplicationContext - з classpath и обробляє контексти як ресурси
		* FileSystemXmlapplicationContext - з файл системи
		* XmlWebXmlapplicationContext - з файлу всередені
	
__________________________________________________________________________________________________________
Связывание компонентов
В Spring объекты не отвечают за поиск или создание других объектов, необходимых для выполнения работы. Вместо этого контейнер передает им ссылки на объекты, с которыми они должны взаимодействовать.
Создание взаимосвязей между прикладными объектами является сущностью технологии внедрения зависимостей (DI) и обычно называется связыванием (wiring).
1. Объявление компонентов
	1.1 Объявление компонентов - создание интерфейса
	1.2 Подготовка конфигурации Spring - необходимо сконфигурировать фреймворк Spring, чтобы сообщить ему, какие компоненты должны находиться в контейнере и как они должны быть связаны между собой:
		* описывается в одном или более XML-файлах:
			* несколько пространств имен XML, посредством которых выполняется настройка контейнера Spring:
				* aop
				* beans
				* context
				* jee
				* jms
				* lang
				* mvc
				* oxm
				* tx
				* util
				* многие проекты из экосистемы Spring, такие как Spring Security, Spring Web Flow и Spring Dynamic Modules,добавляют собственные пространства имен для определения конфигураций
			* конкретній єкземпляр тоже в конф файле: <bean id="duke" class="com.springinaction.springidol.Juggler" />
			* В действительности фреймворк Spring создает компоненты, используя механизм рефлексии.
		* программній код джава
	1.3 Запуск:
		ApplicationContext ctx = new ClassPathXmlApplicationContext(
 "com/springinaction/springidol/spring-idol.xml");
Performer performer = (Performer) ctx.getBean("duke");
performer.perform();
	1.4 Внедрение через конструкторы
		1.4.1 Создание компонентов с помощью статических фабричных методов: <bean id="theStage" 	 class="com.springinaction.springidol.Stage" 	 factory-method="getInstance" />
		1.4.2 Область действия компонента:
			* По умолчанию все компоненты Spring единичны!
			* создавать новый экземпляр при каждом обращении, в объявление компонента следует добавить атрибут scope со значением "области действия"(singletonт (по умолчанию) prototype request session global-session):
			<bean id="ticket" 	 class="com.springinaction.springidol.Ticket" scope="prototype" />
		1.4.3 Инициализация и уничтожение компонентов:
			1.4.3.1 классика:
				* атрибут init-method определяет метод, вызываемый сразу после создания экземпляра компонента. 
				* атрибут destroy-method определяет метод, вызываемый непосредственно перед удалением компонента из контейнера.
				* Если в файле определения контекста необходимо определить множество компонентов с методами инициализации или уничтожения , имеющими одинаковые имена, то добавить атрибуты default-init-method и default-destroy-method в элемент <beans>
			1.4.3.2 через интерфейси: реализовать в классе компонента интерфейсы InitializingBean и DisposableBean ( недостаток состоит в образовании тесной связи между прикладными компонентами и Spring API !!!)
	1.5 Внедрение в свойства компонентов ():
		* Внедрение простых значений - Элемент <property> в XML предписывает фреймворку Spring вызвать метод setSong() для записи значения "Jingle Bells" в свойство song. 
		* Внедрение ссылок на другие компоненты - Настоящая ценность DI заключается в возможности связывания взаимодействующих объектов, чтобы они не связывали себя сами:
			* Внедрение внутренних компонентов - – это компоненты, которые определяются внутри других компонентов (аля внутренние класи):
				<bean id="kenny" 
 class="com.springinaction.springidol.Instrumentalist">
 <property name="song" value="Jingle Bells" />
 <property name="instrument">
	<bean class="org.springinaction.springidol.Saxophone" />
 </property>
</bean>
	1.6 Связывание свойств с помощью пространства имен p - альтернатива элементу <property>
	92
	